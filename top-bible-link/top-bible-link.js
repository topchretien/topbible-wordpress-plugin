/**
 * Backbone Application File
 * @internal Obviously, I've dumped all the code into one file. This should probably be broken out into multiple
 * files and then concatenated and minified but as it's an example, it's all one lumpy file.
 * @package tbleditor.backbone_modal
 */

/**
 * @type {Object} JavaScript namespace for our application.
 */
var tbleditor = {
	backbone_modal: {
		__instance: undefined
	}
};

/**
 * JSON object used to store response
 */
var JSONresponse = {};

/**
 * Primary Modal Application Class
 */
tbleditor.backbone_modal.Application = Backbone.View.extend(
	{
		id: "backbone_modal_dialog",
		events: {
			"click .backbone_modal-close": "closeModal",
			"click #btn-cancel": "closeModal",
			"click #btn-ok": "saveModal",
			"click #btn-search": "searchModal",
			"click .navigation-bar a": "doNothing"
		},

		/**
		 * Simple object to store any UI elements we need to use over the life of the application.
		 */
		ui: {
			nav: undefined,
			content: undefined
		},

		/**
		 * Container to store our compiled templates. Not strictly necessary in such a simple example
		 * but might be useful in a larger one.
		 */
		templates: {},

		/**
		 * Instantiates the Template object and triggers load.
		 */
		initialize: function () {
			"use strict";

			_.bindAll( this, 'render', 'preserveFocus', 'closeModal', 'saveModal', 'doNothing' );
			this.initialize_templates();
			this.render();
		},


		/**
		 * Creates compiled implementations of the templates. These compiled versions are created using
		 * the wp.template class supplied by WordPress in 'wp-util'. Each template name maps to the ID of a
		 * script tag ( without the 'tmpl-' namespace ) created in template-data.php.
		 */
		initialize_templates: function () {
			this.templates.window = wp.template( "tbleditor-modal-window" );
			this.templates.backdrop = wp.template( "tbleditor-modal-backdrop" );
			this.templates.menuItem = wp.template( "tbleditor-modal-menu-item" );
			this.templates.menuItemSeperator = wp.template( "tbleditor-modal-menu-item-separator" );
		},

		/**
		 * Assembles the UI from loaded templates.
		 * @internal Obviously, if the templates fail to load, our modal never launches.
		 */
		render: function () {
			"use strict";

			// Build the base window and backdrop, attaching them to the $el.
			// Setting the tab index allows us to capture focus and redirect it in Application.preserveFocus
			this.$el.attr( 'tabindex', '0' )
				.append( this.templates.window() )
				.append( this.templates.backdrop() );


			// The l10n object generated by wp_localize_script() should be available, but check to be sure.
			// Again, this is a trivial example for demonstration.
			if ( typeof tbleditor_backbone_modal_l10n === "object" ) {
				this.ui.content = this.$( '.backbone_modal-main article' )
					.append( "<p>" + tbleditor_backbone_modal_l10n.replace_message + "</p>" );
			}

			// Handle any attempt to move focus out of the modal.
			jQuery( document ).on( "focusin", this.preserveFocus );

			// set overflow to "hidden" on the body so that it ignores any scroll events while the modal is active
			// and append the modal to the body.
			// TODO: this might better be represented as a class "modal-open" rather than a direct style declaration.
			jQuery( "body" ).css( {"overflow": "hidden"} ).append( this.$el );

			// Set focus on the modal to prevent accidental actions in the underlying page
			// Not strictly necessary, but nice to do.
			this.$el.focus();
		},

		/**
		 * Ensures that keyboard focus remains within the Modal dialog.
		 * @param e {object} A jQuery-normalized event object.
		 */
		preserveFocus: function ( e ) {
			"use strict";
			if ( this.$el[0] !== e.target && ! this.$el.has( e.target ).length ) {
				this.$el.focus();
			}
		},

		/**
		 * Closes the modal and cleans up after the instance.
		 * @param e {object} A jQuery-normalized event object.
		 */
		closeModal: function ( e ) {
			"use strict";

			e.preventDefault();
			this.undelegateEvents();
			jQuery( document ).off( "focusin" );
			jQuery( "body" ).css( {"overflow": "auto"} );
			this.remove();
			tbleditor.backbone_modal.__instance = undefined;
		},

		/**
		 * Responds to the btn-ok.click event
		 * @param e {object} A jQuery-normalized event object.
		 * @todo You should make this your own.
		 */
		saveModal: function ( e ) {
			"use strict";
			var textToInsert = "";
			if (JSONresponse.length !== 0) {
				for (var i = 0; i < JSONresponse.length; i++) {
					if (JSONresponse[i]['selected'] === true) {
						textToInsert = textToInsert +
						JSONresponse[i]['text']+
						' (<a class="button" href="' + 
						JSONresponse[i]['url'] + '">' + 
						JSONresponse[i]['ref'] + '</a>) ';
					}
				}
			}
			
			tinymce.execCommand('mceInsertContent', false, textToInsert);
			this.closeModal( e );
		},

		/**
		 * Responds to the btn-search.click event
		 * @param e {object} A jQuery-normalized event object.
		 * @todo You should make this your own.
		 */
		searchModal: function ( e ) {
			"use strict";
			var userText = document.getElementById('userSearchText').value;
			
			if (userText.length === 0) {
				return;
			}

			// Sends a low level Ajax request
			tinymce.util.XHR.send({

			   url: 'https://topbible.topchretien.com/verset/api/verse?q=' + userText,

			   success: function(response) {

			      	if (response.length !== 0) {
			      		JSONresponse = tinymce.util.JSON.parse(response);
			      		if (JSONresponse.length !== 0) {
			      			// console.debug( JSONresponse );
							// editor.execCommand('mceInsertContent', false, JSONresponse[0]['text']+' (<a class="button" href="' + JSONresponse[0]['url'] + '">' + JSONresponse[0]['ref'] + '</a>)');
			      			var result = "<ul>";

			      			for (var i = 0; i < JSONresponse.length; i++) {
			      				result = result +
			      				"<li onclick='tbleditor.backbone_modal.__instance.clickOnSearchList(this,"+i+")'><h3>" +
			      				JSONresponse[i]['ref']+
			      				"</h3><p>"+
			      				JSONresponse[i]['text']+
			      				"</p></li>";	
			      				JSONresponse[i]['selected'] = false;
			      			}

			      			result = result+"</ul>";

			      			document.getElementById('resultSearch').innerHTML = "<p>"+result+"</p>";
			      		} else {
			      			console.debug( 'Empty answer from API...' );
			      			document.getElementById('resultSearch').innerHTML = "<p>Can't find anything</p>";
			      			return;
			      		}

			      	} else {
			      		console.debug( 'No answer from API...' );
			      		document.getElementById('resultSearch').innerHTML = "<p>Can't find anything</p>";
			      		return;
			      	}
			      	
			   },

			   error: function() {
			   		console.debug( 'Can\'t connect to the API...' );
			   		document.getElementById('resultSearch').innerHTML = "<p>Can't find anything</p>";
			   		return;
			   } 

			});

		},

		/**
		 * Ensures that events do nothing.
		 * @param e {object} A jQuery-normalized event object.
		 * @todo You should probably delete this and add your own handlers.
		 */
		doNothing: function ( e ) {
			"use strict";
			e.preventDefault();
		},

		/**
		 * Click
		 * @param e {object} A jQuery-normalized event object.
		 * @todo You should probably delete this and add your own handlers.
		 */
		clickOnSearchList: function ( elm,id ) {
			"use strict";

			if (JSONresponse[id]['selected'] === false) {
				JSONresponse[id]['selected'] = true;
				elm.classList.add('selected');
			} else {
				JSONresponse[id]['selected'] = false;
				elm.classList.remove('selected');
			}
		}

	} );

(function() {

	tinymce.PluginManager.add( 'top_bible_link_class', function( editor, url ) {

		// Add Button to Visual Editor Toolbar
		editor.addButton('top_bible_link_class', {
			title: 'Insert Link to TopBible',
			cmd: 'top_bible_link_class',
			image: url + '/link.png',
		});	

		// Add Command when Button Clicked
		editor.addCommand('top_bible_link_class', function() {

			if ( tbleditor.backbone_modal.__instance === undefined ) {
				tbleditor.backbone_modal.__instance = new tbleditor.backbone_modal.Application();
			}

			

		});


	});

})();
